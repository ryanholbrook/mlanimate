#+TITLE: Decision Boundaries
#+AUTHOR: Ryan Holbrook
#+PROPERTY: header-args :tangle yes

* Optimal Decision Boundaries
** Introduction

Over the next few posts, we will investigate /decision boundaries/. A decision boundary is a graphical representation of the solution to a classification problem. Decision boundaries can help us to understand what kind of solution might be appropriate for a problem. They can also help us to understand the how various machine learning classifiers arrive at a solution.

In this post, we will look at a problem's /optimal/ decision boundary, which we can find when we know exactly how our data was generated. The optimal decision boundary represents the "best" solution possible for that problem. Consequently, by looking at the complexity of this boundary and at how much error it produces, we can get an idea of the inherent difficulty of the problem. 

Unless we have generated the data ourselves, we won't usually be able to find the optimal boundary. Instead, we approximate it using a classifier. A good machine learning classifier tries to approximate the optimal boundary for a problem as closely as possible.

In future posts, we will look at the approximating boundary created by various classification algorithms. We will investigate the strategy the classifier uses to create this boundary and how this boundary evolves as the classifier is trained on more and more data. There are many classification algorithms available to a data scientist -- regression, discriminant analysis, decision trees, neural networks, to name a few -- and it is important to understand which algorithm is appropritate for the problem at hand. Decision boundaries can help us to do this.

#+name: imbalance-mvn
#+BEGIN_EXPORT html
<video autoplay loop mutued playsinline>
  <source src="./images/rf_mix.webm" type="video/webm">
  <source src="./images/rf_mix.mp4" type="video/mp4">
</video>
#+END_EXPORT
# #+HTML: <figcaption>A random forest learning a classification rule.</figcaption>


** Optimal Boundaries

A classification problem asks: given some observations of a thing, what is the best way to assign that thing to a class based on some of its features? For instance, we might want to predict whether a person will like a movie or not based on some data we have about them, the "features" of that person.

A solution to the classification problem is a rule that partitions the features and assigns each all the features of a partition to the same class. The "boundary" of this partitioning is the *decision boundary* of the rule.

It might be that two observations have exactly the same features, but are assigned to different classes. (Two things that look the same in the ways we've observed might differ in ways we haven't observed.) In terms of probabilities this means both
\[P(C = 0 \mid X) \gt 0\] 
and 
\[P(C = 1 \mid X) \gt 0\].
In other words, we might not be able with full certainty to classify an observation. We could however assign the observation to its /most probable/ class. This gives us the decision rule
\[ \hat{C} = \operatorname*{argmax}_c P(C = c \mid X) \]

The boundary that this rule produces is the *optimal decision boundary*. It is the [[https://en.wikipedia.org/wiki/Maximum_a_posteriori_estimation][MAP estimate]] of the class label, and it is the rule that minimizes classification error under the [[https://en.wikipedia.org/wiki/Loss_function#0-1_loss_function][zero-one loss function]]. We will look at error and loss more in a future post.

We will consider /binary/ classification problems, meaning, there will only be two possible classes, 0 or 1. For a binary classification problem, the optimal boundary occurs at those points where each class is equally probable:
\[ P(C = 0 \mid X) = \P(C = 1 \mid X) \]

** Prepare R

We will use R to do our analysis. We'll have a chance to try out `gganimate` and `patchwork`, a couple of newer packages that [[https://www.data-imaginist.com/][Thomas Lin Pedersen]] has been working on; they are really nice.

Here we'll define some functions to produce plots of our examples. All of these assume a classification problem where our response is binary, $C \in \{0, 1\}$, and is predicted by two continuous features, $(X, Y)$.

Briefly, they are
1. ~gg_sample~ :: creates a layer for a sample of the features colored by class.
2. ~gg_density~ :: creates a layer of contour plots for feature densities within each class.
3. ~gg_optimal~ :: creates a layer showing an optimal decision boundary.
4. ~gg_mix_label~ :: creates a layer labelling components in a mixture distribution. 

#+BEGIN_EXPORT HTML
<p>
#+END_EXPORT

#+begin_src r
library(magrittr)
library(tidyverse)
library(ggplot2)
library(gganimate)
library(patchwork)

theme_set(theme_linedraw() +
          theme(plot.title = element_text(size = 20),
                legend.position = "none",
                axis.text.x = element_blank(),
                axis.text.y = element_blank(),
                axis.title.x = element_blank(),
                axis.title.y = element_blank(),
                aspect.ratio = 1))

#' Make a sample layer
#'
#' @param data data.frame: a sample with continuous features `x` and `y`
#' grouped by factor `class`
#' @param classes (optional) a vector of which levels of `class` to
#' plot; default is to plot data from all classes
gg_sample <- function(data, classes = NULL, size = 3, alpha = 0.5, ...) {
    if (is.null(classes)) {
        subdata <- data
    } else {
        subdata <- filter(data, class %in% classes)
    }
    list(geom_point(data = subdata,
                    aes(x, y,
                        color = factor(class),
                        shape = factor(class)),
                    size = size,
                    alpha = alpha,
                    ...),
         scale_colour_discrete(drop = TRUE,
                               limits = levels(factor(data$class))))
}

#' Make a density layer
#'
#' @param data data.frame: a data grid of features `x` and `y` with contours `z`
#' @param data character: the name of the contour column 
gg_density <- function(data, z, size = 1, color = "black", alpha = 1, ...) {
    z <- ensym(z)
    geom_contour(data = data,
                 aes(x, y, z = !!z),
                 size = size,
                 color = color,
                 alpha = alpha,
                 ...)
}

#' Make an optimal boundary layer
#'
#' @param data data.frame: a data grid of features `x` and `y` with a column with
#' the `optimal` boundary contours
#' @param breaks numeric: which contour levels of `optimal` to plot
gg_optimal <- function(data, breaks = c(0), ...) {
    gg_density(data, z = optimal, breaks = breaks, ...)
}

#' Make a layer of component labels for a mixture distribution with two classes
#'
#' @param mus list(data.frame): the means for components of each class; every row
#' is a mean, each column is a coordinate
#' @param classes (optional) a vector of which levels of class to plot
gg_mix_label <- function(mus, classes = NULL, size = 10, ...) {
    ns <- map_int(mus, nrow)
    component <- do.call(c, map(ns, seq_len))
    class <- do.call(c, map2(0:(length(ns) - 1), ns, rep.int))
    mu_all <- do.call(rbind, mus)
    data <- cbind(mu_all, component, class) %>%
        set_colnames(c("x", "y", "component", "class")) %>%
        as_tibble()
    if (is.null(classes)) {
        subdata <- data
    } else {
        subdata <- filter(data, class %in% classes)
    }    
    list(shadowtext::geom_shadowtext(data = subdata,
                                     mapping = aes(x, y,
                                                   label = component,
                                                   color = factor(class)),
                                     size = size,
                                     ...),
         scale_colour_discrete(drop = TRUE,
                               limits = levels(factor(data$class))))
}

#+end_src


** Decision Boundaries for Continuous Features

Decision boundaries are most easily visualized whenever we have /continuous/ features, most especially when we have /two/ continuous features, because then the decision boundary will exist in a plane.

With two continuous features, the feature space will form a plane, and a decision boundary in this feature space is a set of one or more curves that divide the plane into distinct regions. Inside of a region, all observations will be assigned to the same class.

# image of 1D decision boundaries

As mentioned above, whenever we know exactly how our data was generated, we can produce the optimal decision boundary. Though this won't usually be possible in practice, investigating the optimal boundaries produced from simulated data can still help us to understand their properties.

We will look at the optimal boundary for a binary classification problem on a with features on a couple of common distributions: a multivariate normal distribution and a mixture of normal distributions.


*** Normally Distributed Features

In a binary classification problem, whenever the features for each class jointly have a multivariate normal distribution, the optimal decision boundary is relatively simple. We will start our investigation here.

With two features, the feature space is a plane. It can be shown that the optimal decision boundary in this case will either be a line or a [[https://en.wikipedia.org/wiki/Conic_section][conic section]] (that is, an ellipse, a parabola, or a hyperbola). With higher dimesional feature spaces, the decision boundary will form a [[https://en.wikipedia.org/wiki/Hyperplane][hyperplane]] or a [[https://en.wikipedia.org/wiki/Quadric][quadric surface]].

We will consider classification problems with two classes, $C = {0, 1}$, and two features, $X$ and $Y$. Each class will be Bernoulli distributed and the features for each class will be distributed normally. Specifically,

|----------------------+---------------------------------------------------------------------|
| Classes              | \( C \sim \operatorname{Bernoulli}(p) \)                            |
| Features for Class 0 | \( (X, Y) \mid C = 0 \sim \operatorname{Normal}(\mu_0, \Sigma_0) \) |
| Features for Class 1 | \( (X, Y) \mid C = 1 \sim \operatorname{Normal}(\mu_0, \Sigma_1) \) |
|----------------------+---------------------------------------------------------------------|

Our goal is to produce two kinds of visualizations: one, of a sample from these distributions, and two, the contours of the class-conditional densities for each feature. We'll use the ~mvnfast~ package to help us with computations on the joint MVN.


**** Samples

Let's choose some values for our parameters. We'll start with the case when the classes occur equally often. For our features, we'll choose means so that there is some significant overlap between the two classes, and covariance matrices so that the distributions have a nice elliptical shape.

#+begin_src r
p <- 0.5
mu_0 <- c(0, 2)
sigma_0 <- matrix(c(1, 0.3, 0.3, 1), nrow = 2)
mu_1 <- c(2, 0)
sigma_1 <- matrix(c(1, -0.3, -0.3, 1), nrow = 2)
#+end_src

Now we'll write a function to create a dataframe containing a sample of classified features from our distribution.

#+begin_src r
#' Generate normally distributed feature samples for a binary
#' classification problem
#'
#' @param n integer: the size of the sample
#' @param mean_0 vector: the mean vector of the first class
#' @param sigma_0 matrix: the 2x2 covariance matrix of the first class
#' @param mean_1 vector: the mean vector of the second class
#' @param sigma_1 matrix: the 2x2 covariance matrix of the second class
#' @param p_0 double: the prior probability of class 0
make_mvn_sample <- function(n, mu_0, sigma_0, mu_1, sigma_1, p_0) {
    n_0 <- rbinom(1, n, p_0)
    n_1 <- n - n_0
    sample_mvn <- as_tibble(
        rbind(mvnfast::rmvn(n_0,
                            mu = mu_0,
                            sigma = sigma_0),
              mvnfast::rmvn(n_1,
                            mu = mu_1,
                            sigma = sigma_1)))
    sample_mvn[1:n_0, 3] <- 0
    sample_mvn[(n_0 + 1):(n_0 + n_1), 3] <- 1
    sample_mvn <- sample_mvn[sample(nrow(sample_mvn)), ]
    colnames(sample_mvn) <- c("x", "y", "class")
    sample_mvn
}

#+end_src

Finally, we'll create a sample of 4000 points and plot the result.

#+begin_src r
n <- 4000
set.seed(31415)
sample_mvn <- make_mvn_sample(n,
                              mu_0, sigma_0,
                              mu_1, sigma_1,
                              p)

ggplot() +
    gg_sample(sample_mvn) +
    coord_fixed()
#+end_src

#+caption: A sample of the feature distributions for each class.
#+ATTR_HTML: :width 400px
#+name: sample-mvn
[[file:./images/sample_mvn.png]]


It should be apparent that because of the overlap in these distributions, any decision rule will necessarily misclassify some observations fairly often.


**** Classes on the Feature Space

Next, we will produce some contour plots of our feature distributions. Let's write a function to generate class probabilities at any observation $(x, y)$ in the feature space; we will model the optimal decision boundary as those points where the posterior probabilities of the two classes are equal, that is, where 
\[ P(X, Y \mid C = 0) P(C = 0) - P(X, Y \mid C = 1) P(C = 1) = 0 \]

#+begin_src r
#' Make an optimal prediction at a point from two class distributions
#'
#' @param x vector: input
#' @param p_0 double: prior probability of class 0
#' @param dfun_0 function(x): density of features of class 0
#' @param dfun_1 function(x): density of features of class 1
optimal_predict <- function(x, p_0, dfun_0, dfun_1) {
    ## Prior probability of class 1
    p_1 <- 1 - p_0
    ## Conditional probability of (x, y) given class 0
    p_x_0 <- dfun_0(x)
    ## Conditional probability of (x, y) given class 1
    p_x_1 <- dfun_1(x)
    ## Conditional probability of class 0 given (x, y)
    p_0_xy <- p_x_0 * p_0
    ## Conditional probability of class 1 given (x, y)
    p_1_xy <- p_x_1 * p_1
    optimal <- p_1_xy - p_0_xy
    class <- ifelse(optimal > 0, 1, 0)
    result <- c(p_0_xy, p_1_xy, optimal, class)
    names(result) <- c("p_0_xy", "p_1_xy", "optimal", "class")
    result
}

#' Construct a dataframe with posterior class probabilities and the
#' optimal decision boundary over a grid on the feature space
#' 
#' @param mean_0 vector: the mean vector of the first class
#' @param sigma_0 matrix: the 2x2 covariance matrix of the first class
#' @param mean_1 vector: the mean vector of the second class
#' @param sigma_1 matrix: the 2x2 covariance matrix of the second class
#' @param p_0 double: the prior probability of class 0
make_density_mvn <- function(mean_0, sigma_0, mean_1, sigma_1, p_0,
                             x_min, x_max, y_min, y_max, delta = 0.05) {
    x <- seq(x_min, x_max, delta)
    y <- seq(y_min, y_max, delta)
    density_mvn <- expand.grid(x, y)
    names(density_mvn) <- c("x", "y")
    dfun_0 <- function(x) mvnfast::dmvn(x, mu_0, sigma_0)
    dfun_1 <- function(x) mvnfast::dmvn(x, mu_1, sigma_1)
    optimal_mvn <- function(x, y) optimal_predict(c(x, y), p_0, dfun_0, dfun_1)
    density_mvn <-as.tibble(
        cbind(density_mvn,
              t(mapply(optimal_mvn,
                       density_mvn$x, density_mvn$y))))
    density_mvn
}

#+end_src


Now we can generate a grid of points and compute posterior class probabilities over that grid. By plotting these probabilities, we can get describe both the conditional feature distributions for each class as well as the joint feature distribution.

#+begin_src r
density_mvn <- make_density_mvn(mu_0, sigma_0, mu_1, sigma_1, p,
                                -3, 5, -3, 5)

(ggplot() +
 gg_sample(sample_mvn, alpha = 0.1) +
 gg_density(density_mvn, z = p_0_xy) +
 gg_density(density_mvn, z = p_1_xy) +
 ggtitle("Conditional Distributions")) +
(ggplot() +
 gg_sample(sample_mvn, alpha = 0.1) +
 geom_contour(data = density_mvn,
              aes(x = x, y = y, z = p_0_xy + p_1_xy),
              size = 1,
              color = "black") +
 ggtitle("Joint Distribution"))

#+end_src

#+caption: Contours of the feature distributions for each class.
#+ATTR_HTML: :width 800px
#+name: density-mvn
[[file:./images/density_mvn.png]]

**** The Optimal Decision Boundary

Now let's add a plot for the optimal decision boundary for this problem.

#+begin_src r
(ggplot() +
 gg_density(density_mvn, z = p_0_xy,
            alpha = 0.25) +
 gg_density(density_mvn, z = p_1_xy,
            alpha = 0.25) +
 gg_optimal(density_mvn)) +
(ggplot() +
 gg_sample(sample_mvn, alpha = 0.25) +
 gg_optimal(density_mvn)) +
plot_annotation("The Optimal Decision Boundary")

#+end_src

#+caption: The optimal decision boundary
#+ATTR_HTML: :width 800px
#+name: optimal-mvn
[[file:./images/optimal_mvn.png]]

Notice how the boundary runs through the points where the contours of the two conditional distributions intersect. These points of intersection are where the classes have equal posterior probability.


*** Mixture of Normals

The features of each class might also be modeled as a /mixture/ of normal distributions. This means that each observation in a class will come from one of /several/ normal distributions; in our case, the distributions from a class will be joined by a common hyperparameter, their mean.

In description, at least, the problem is still relatively simple. The possible decision boundaries produced, however, can be quite complex. This is a much more difficult problem than the one we saw before.

For our examples, we will generate the data as follows:
|---------------------------------+-----------------------------------------------------------------------------------------------------------------------|
| Classes                         | \( C \sim Bernoulli(p) \)                                                                                             |
| Mean of Means for Class 0       | \( \nu_0 \sim Normal((0, 1), I) \)                                                                                    |
| Mean of Means for Class 1       | \( \nu_0 \sim Normal((1, 0), I) \)                                                                                    |
| Means of Components for Class 0 | \( \mu_{0, i=1, \ldots, n_0} \sim Normal(\nu_0, I) \)                                                                 |
| Means of Components for Class 1 | \( \mu_{1, i=1, \ldots, n_1} \sim Normal(\nu_1, I) \)                                                                 |
| Features for Class 0            | \( (X, Y) \mid C = 0 \sim w_{0, 1} Normal(\mu_{0, 1}, \Sigma_0) + \cdots + w_{0, l_0} Normal(\mu_{0, 0}, \Sigma_0) \) |
| Features for Class 1            | \( (X, Y) \mid C = 1 \sim w_{1, 1} Normal(\mu_{1, 1}, \Sigma_1) + \cdots + w_{1, l_1} Normal(\mu_{1, l_1}, \Sigma_1) \) |
|---------------------------------+-----------------------------------------------------------------------------------------------------------------------|

where $n_0$ is the number of components for class 0, $w_{0, i}$ are the weights on each component, $\Sigma_0 = \frac{1}{2 * l_0} I$, and $I$ is the identity matrix; similarly for class 1.

This is a bit awful, but we are basically doing this: 

For each class, define the distribution of the features $(X, Y)$ by
1. Choosing the number of components to go in the mixture.
2. Choosing a mean for each component by sampling from a normal distribution.

Then, to get a sample: Get an observation by
1. Choosing a class, 0 or 1.
2. Choosing a component from that class, a normal distribution.
3. Sample the observation from that component.

**** Samples

The computations for the mixture of MVNs are fairly similar to the ones we did before. First let's define a sampling function. This function just implements the above steps.

#+begin_src r
#' Generate normally distributed feature samples for a binary
#' classification problem
#'
#' @param n integer: the size of the sample
#' @param nu_0 numeric: the average mean of the components of the first feature
#' @param sigma_0 matrix: covariance of components of the first feature
#' @param n_0 integer: class frequency of first feature in the sample
#' @param w_0 numeric: vector of weights for components of the first feature
#' @param mean_1 numeric: the average mean of the components of the second feature
#' @param sigma_1 matrix: covariance of components of the second feature
#' @param n_1 integer: class frequency of second feature in the sample
#' @param w_1 numeric: vector of weights for components of the second feature
#' @param p_0 double: the prior probability of class 0
make_mix_sample <- function(n,
                            nu_0, tau_0, n_0, sigma_0, w_0,
                            nu_1, tau_1, n_1, sigma_1, w_1,
                            p_0) {
    ## Number of Components for Each Class
    l_0 <- length(w_0)
    l_1 <- length(w_1)
    ## Sample the Component Means
    mu_0 <- mvnfast::rmvn(n = l_0,
                          mu = nu_0, sigma = tau_0)
    mu_1 <- mvnfast::rmvn(n = l_1,
                          mu = nu_1, sigma = tau_1)
    ## Class Frequency in the Sample
    n_0 <- rbinom(1, n, p_0)
    n_1 <- n - n_0
    ## Sample the Features
    f_0 <- mvnfast::rmixn(n = n_0,
                          mu = mu_0, sigma = sigma_0, w = w_0,
                          retInd = TRUE)
    c_0 <- attr(f_0, "index")
    f_1 <- mvnfast::rmixn(n = n_1,
                          mu = mu_1, sigma = sigma_1, w = w_1,
                          retInd = TRUE)
    c_1 <- attr(f_1, "index")
    sample_mix <- as.data.frame(rbind(f_0, f_1))
    sample_mix[, 3] <- c(c_0, c_1)
    ## Define Classes
    sample_mix[1:n_0, 4] <- 0
    sample_mix[(n_0 + 1):(n_0 + n_1), 4] <- 1
    sample_mix <- sample_mix[sample(nrow(sample_mix)), ]
    names(sample_mix) <- c("x", "y", "component", "class")
    ## Store Component Means
    attr(sample_mix, "mu_0") <- mu_0
    attr(sample_mix, "mu_1") <- mu_1
    sample_mix
}

#+end_src

Now we'll define the parameters, construct a sample, and look at the result.

#+begin_src r

## Bernoulli parameter for class distribution
p = 0.5
## Mean of component means
nu_0 = c(0, 1)
nu_1 = c(1, 0)
## Covariance for component means
tau_0 = matrix(c(1, 0, 0, 1), nrow = 2)
tau_1 = matrix(c(1, 0, 0, 1), nrow = 2)
## Number of components for each class
n_0 <- 10
n_1 <- 10
## Covariance for each class
sigma_0 <- replicate(n_0, matrix(c(1, 0, 0, 1), 2) / n_0 * 2,
                     simplify = FALSE)
sigma_1 <- replicate(n_1, matrix(c(1, 0, 0, 1), 2) / n_1 * 2,
                     simplify = FALSE)
## Weights of mixture components
w_0 <- rep(1 / n_0, n_0)
w_1 <- rep(1 / n_1, n_1)

## Sample size
n <- 4000
set.seed(31)
sample_mix <- make_mix_sample(n,
                              nu_0, tau_0, n_0, sigma_0, w_0,
                              nu_1, tau_1, n_1, sigma_1, w_1,
                              p)
## Retrieve the generated component means
mu_0 <- attr(sample_mix, "mu_0")
mu_1 <- attr(sample_mix, "mu_1")

ggplot() +
    gg_sample(sample_mix) +
    ggtitle("Sample of Mixture Distribution")

ggplot() +
    gg_sample(sample_mix) +
    gg_mix_label(list(mu_0, mu_1)) +
    facet_wrap(vars(class)) +
    ggtitle("Feature Components")

#+end_src

#+caption: A sample of the feature distributions for each class.
#+ATTR_HTML: :width 800px
#+name: sample-mix
[[file:./images/sample.png]]

We've labelled the component means for each class. (There are 10 components for class 0, and 10 components for class 1.) You can see that around each of these labels is a sample from a normal distribution.

**** Classes on the Feature Space

Now we'll compute class probabilities on the feature space.

First define a generating function.

#+begin_src r
#' Construct a dataframe with posterior class probabilities and the
#' optimal decision boundary over a grid on the feature space
#' 
#' @param mean_0 numeric: the average mean of the components of the first feature
#' @param sigma_0 matrix: covariance of components of the first feature
#' @param w_0 numeric: vector of weights for components of the first feature
#' @param mean_1 numeric: the average mean of the components of the second feature
#' @param sigma_1 matrix: covariance of components of the second feature
#' @param w_1 numeric: vector of weights for components of the second feature
#' @param p_0 double: the prior probability of class 0
make_density_mix <- function(mean_0, sigma_0, w_0,
                             mean_1, sigma_1, w_1, p_0,
                             x_min, x_max, y_min, y_max, delta = 0.05) {
    x <- seq(x_min, x_max, delta)
    y <- seq(y_min, y_max, delta)
    density_mix <- expand.grid(x, y)
    names(density_mix) <- c("x", "y")
    dfun_0 <- function(x) mvnfast::dmixn(matrix(x, nrow = 1),
                                         mu = mean_0,
                                         sigma = sigma_0,
                                         w = w_0)
    dfun_1 <- function(x) mvnfast::dmixn(matrix(x, nrow = 1),
                                         mu = mean_1,
                                         sigma = sigma_1,
                                         w = w_1)
    optimal_mix <- function(x, y) optimal_predict(c(x, y), p_0, dfun_0, dfun_1)
    density_mix <-as.tibble(
        cbind(density_mix,
              t(mapply(optimal_mix,
                       density_mix$x, density_mix$y))))
    density_mix
}
#+end_src

And now compute the grid and plot.

#+begin_src r
density_mix <- make_density_mix(mu_0, sigma_0, w_0, mu_1, sigma_1, w_1, p,
                                -3, 5, -3, 5)

(ggplot() +
 gg_sample(sample_mix, classes = 0,
           alpha = 0.1) +
 gg_density(density_mix, z = p_0_xy) +
 gg_mix_label(list(mu_0, mu_1), classes = 0) +
 ggtitle("Density of Class 0")) +
(ggplot() +
 gg_sample(sample_mix, classes = 1,
           alpha = 0.1) +
 gg_density(density_mix, z = p_1_xy) +
 gg_mix_label(list(mu_0, mu_1), classes = 1) +
 ggtitle("Density of Class 1")) +
(ggplot() +
 gg_sample(sample_mix,
           alpha = 0.1) +
 geom_contour(data = density_mix,
              aes(x = x, y = y, z = p_0_xy + p_1_xy),
              color = "black",
              size = 1) +
 ggtitle("Joint Density"))

#+end_src

#+caption: Contours of the feature distributions for each class.
#+ATTR_HTML: :width 800px
#+name: density-mix
[[file:./images/density_mix.png]]


** The Optimal Decision Boundary

And here is the optimal decision boundary for this problem. Notice how again the boundary runs through points of intersection in the two conditional distributions, and how it separates the classes of observations in the sample.

#+begin_src r
(ggplot() +
 gg_density(density_mix, z = p_0_xy,
            alpha = 0.25) +
 gg_density(density_mix, z = p_1_xy,
            alpha = 0.25) +
 gg_optimal(density_mix)) +
(ggplot() +
 gg_sample(sample_mix, alpha = 0.25) +
 gg_optimal(density_mix))
#+end_src

#+caption: The optimal decision boundary.
#+ATTR_HTML: :width 800px
#+name: optimal-mix
[[file:./images/optimal_mix.png]]


** Class Imbalance

So far, we've only seen the case where the two classes occur about equally often. If one class has a lower probability of occuring (say class 1), then the optimal decision boundary must move toward the class 1 distribution in order to equalize the probabilities on either side. This should help illustrate why it's important to consider class imbalance whenever you're working on a classification problem. A large imbalance can change your decisions drastically.

To see this change, we will use the ~gganimate~ package to produce an animation showing how the optimal boundary changes as the Bernoulli parameter (the frequency of class 0) changes from 0.1 to 0.9.

*** Normally Distributed Features

#+begin_src r
## Evaluate mu_0, sigma_0, etc. again, if needed.

density_p0 <-
    map_dfr(seq(0.1, 0.9, 0.005),
            function(p_0)
                make_density_mvn(mu_0, sigma_0, mu_1, sigma_1,
                                 p_0, -3, 5, -3, 5) %>%
                mutate(p_0 = p_0))

anim <- ggplot() +
    geom_contour(data = density_p0,
                 aes(x = x, y = y, z = p_0_xy + p_1_xy),
                 color = "black",
                 size = 1,
                 alpha = 0.25) +
    gg_optimal(density_p0) +
    transition_manual(p_0) +
    ggtitle("Proportion of Class 0: {current_frame}")

anim <- animate(anim, renderer = gifski_renderer(),
                width = 800, height = 800)

anim
#+end_src

#+name: imbalance-mvn
#+BEGIN_EXPORT html
<video autoplay loop mutued playsinline>
  <source src="./images/imbalance_mvn.webm" type="video/webm">
  <source src="./images/imbalance_mvn.mp4" type="video/mp4">
</video>
#+END_EXPORT
# #+HTML: <figcaption>The optimal decision boundary for various levels of class imbalance.</figcaption>



*** Mixture of Normals

#+begin_src r
density_mix_p0 <-
    map_dfr(seq(0.1, 0.9, 0.005),
            function(p_0)
                make_density_mix(mu_0, sigma_0, w_0, mu_1, sigma_1, w_1,
                                 p_0, -3, 5, -3, 5) %>%
                mutate(p_0 = p_0))
anim <- ggplot() +
    geom_contour(data = density_mix_p0,
                 aes(x = x, y = y, z = p_0_xy + p_1_xy),
                 color = "black",
                 size = 1,
                 alpha = 0.25) +
    gg_optimal(density_mix_p0) +
    transition_manual(p_0) +
    ggtitle("Proportion of Class 0: {current_frame}")

anim <- animate(anim, renderer = gifski_renderer(),
                width = 800, height = 800)

anim

#+end_src
a
#+name: imbalance-mix
#+BEGIN_EXPORT html
<video autoplay loop mutued playsinline>
  <source src="./images/imbalance_mix.webm" type="video/webm">
  <source src="./images/imbalance_mix.mp4" type="video/mp4">
</video>
#+END_EXPORT
# #+HTML: <figcaption>The optimal decision boundary for various levels of class imbalance.</figcaption>


# TODO - animations

** Conclusion

In this post, we reviewed *decision boundaries*, a way of visualizing classification rules. In particular, we looked at *optimal* decision boundaries, which represent the /best/ solution possible to a problem given certain costs for misclassification. The rule we used in this post was the *MAP* estimate, which minimizes zero-one loss, where all misclassifications are equally likely.

In future posts, we'll look other kinds of loss functions and how that can affect the decision rule, and also at the boundaries produced by a number of statistical learning models.

Hope you enjoyed it!

* Gaussian Discriminant Analysis

We saw in the post on optimal decision boundaries that the optimal boundary (under [[https://en.wikipedia.org/wiki/Loss_function#0-1_loss_function][zero-one loss]]) is produced by a rule that assigns to an observation the /most probable/ class $c$ given the observed features $X$:

\[ \hat{C} = \operatorname*{argmax}_c P(C = c \mid X) \]

Recall that [[https://en.wikipedia.org/wiki/Bayes%27_theorem][Bayes' theorem]] tells us that this probability \(P(C = c \mid X)\) is proportionate to \(P(X \mid C = c) P(C = c)\). To estimate this optimal classification rule, therefore, a classifier will often attempt to estimate either the maximum of \(P(X \mid C = c) P(C = c)\) (a [[https://en.wikipedia.org/wiki/Maximum_a_posteriori_estimation][MAP]] estimate) or only \(P(X \mid C = c)\) (an [[https://en.wikipedia.org/wiki/Maximum_likelihood_estimation][MLE]] estimate). These estimates converge as the sample size grows.

One kind of classifier will make these estimations by modeling the class-conditional distributions for the features (that is, \(P(X \mid C = c)\)) as [[https://en.wikipedia.org/wiki/Normal_distribution][Normal (or Gaussian) distributions]] \(Normal(\mu_c, \Sigma_c)\) and then using [[https://en.wikipedia.org/wiki/Plug-in_principle][plug-in]] estimates for \(P(X)\) and the parameters \(\mu_c\) and \(\Sigma_c\). This technique is called *Gaussian discriminant analysis* (GDA).

** Naive Bayes Classifiers

The first kind of classifier of this type we will consider is the *naive Bayes* classifier. A naive Bayes classifier, in addition to assuming a distribution for \(P(X \mid C = c)\), also assumes that the features are [[https://en.wikipedia.org/wiki/Conditional_independence][conditionally independent]]. If $X$ is a vector of two features, $X = (X_1, Y_1)$, this means we can write
\[ P(X \mid C = c) = P(X_1 \mid C = c) P(X_2 \mid C = c) \]

This makes computing \(P(X \mid C = c)\) especially easy.

A naive Bayes classifier can model \(P(X_i \mid C = c)\) with a variety of distributions. When the features are binary, it might make sense to use a [[https://en.wikipedia.org/wiki/Bernoulli_distribution][Bernoulli distribution]], for instance. Our features will be real-valued, though, and we will model the features with normal distributions.

Considered as a method of GDA, this means we are modeling the class conditional distributions with [[https://en.wikipedia.org/wiki/Multivariate_normal_distribution][MVNs]] \(Normal(\mu_c | \Sigma_c)\) where each [[https://en.wikipedia.org/wiki/Covariance_matrix][covariance matrix]] is [[https://en.wikipedia.org/wiki/Diagonal_matrix][diagonal]]. (Recall that the off-diagonal entries of $\Sigma_c$ express the covariance between two features, while the diagonal entries of the matrix expresses the variance of individual features. Since we are assuming the features are independent, [[https://en.wikipedia.org/wiki/Correlation_and_dependence#Correlation_and_independence][they must also be uncorrelated]]; hence, only diagonal entries can be non-zero.)

*** Example 1 - Independent Features

Let's first fit a Naive bayes classifier to a data set where the data is actually generated exactly how the NB classifier assumes it will be. Our model will be

|----------------------+---------------------------------------------------------------------|
| Classes              | \(C \sim \operatorname{Bernoulli}(p)\)                              |
| Features for Class 0 | \((X, Y) \mid C = 0 \sim \operatorname{Normal}(\mu_0, \Sigma_0)\)   |
| Features for Class 1 | \((X, Y) \mid C = 1 \sim \operatorname{Normal}(\mu_0, \Sigma_1)\)   |
|----------------------+---------------------------------------------------------------------|

where 

|-------------------------------------------------------------|
| \(p = 0.5\)                                                 |
| \(\mu_0 = (0, 2)\)                                          |
| \(\Sigma_0 = \begin{bmatrix}1 & 0 \\ 0 & 1.5\end{bmatrix}\) |
| \(\mu_1 = (2, 0)\)                                          |
| \(\Sigma_1 = \begin{bmatrix}2 & 0 \\ 0 & 1\end{bmatrix}\)   |
|-------------------------------------------------------------|

First let's define the parameters and generate a sample of 4000 points and then also plot the optimal boundary. (All the necessary functions were defined in the previous post. A repository with the code as an R package can be found [[https://github.com/ryanholbrook/mlanimate][here]].)

#+begin_src r
p <- 0.5
mu_0 <- c(0, 2)
sigma_0 <- matrix(c(1, 0, 0, 1.5), nrow = 2)
mu_1 <- c(2, 0)
sigma_1 <- matrix(c(2, 0, 0, 1), nrow = 2)

n <- 4000
set.seed(31415)
sample_mvn <- make_sample_mvn(n,
                              mu_0, sigma_0,
                              mu_1, sigma_1,
                              p)
density_mvn <- make_density_mvn(mu_0, sigma_0,
                                mu_1, sigma_1,
                                p,
                                -3, 5, -3, 5)


(ggplot() +
 gg_density(density_mvn, z = p_0_xy,
            alpha = 0.25) +
 gg_density(density_mvn, z = p_1_xy,
            alpha = 0.25) +
 gg_optimal(density_mvn)) +
(ggplot() +
 gg_sample(sample_mvn, alpha = 0.25) +
 gg_optimal(density_mvn)) +
plot_annotation("The Optimal Decision Boundary")
#+end_src

We see as before that the optimal boundary runs through points of intersection of the contours. The fact that our features are independent means that the contours can "spread out" only horizontally or vertically. I mean that the major-axis of the ellipse drawn has to be either horizontal or vertical. A diagonal spread would mean that the features were correlated and not independent.

Now let's look at how the classifier fits on this data.

#+begin_src r
fit_mvn_nb <- naivebayes::naive_bayes(factor(class) ~ x + y, data = sample_mvn)
pred_mvn_nb <- predict(fit_mvn_nb, newdata = density_mvn[, c("x", "y")], type = "prob")
density_mvn_nb <- cbind(density_mvn, "fitted" = pred_mvn_nb[, "1"])

gg_plot_boundary(sample_mvn, density_mvn_nb, title = "Naive Bayes")

anim <- animate_boundary(sample_mvn, density_mvn, 10, fit_and_predict_nb)
anim_save("/home/jovyan/work/bayeserror/nb_mvn_perfect.gif")
#+end_src r

We can see that the model fits the optimal boundary quite well.

Here is a confusion matrix. Accurate classification almost 99% of the time.

#+begin_src r
density_mvn_nb[, "assigned"] <- ifelse(density_mvn_nb$fitted > 0, 1, 0)

caret::confusionMatrix(factor(density_mvn_nb$class),
                       factor(density_mvn_nb$assigned))
#+end_src


*** Example 2 - Dependent Features

What happens when the features are correlated within each class? Let's have our data model now be

|---------------------------------------------------------------|
| \(p = 0.5\)                                                   |
| \(\mu_0 = (0, 2)\)                                            |
| \(\Sigma_0 = \begin{bmatrix}1 & 0.5 \\ 0.5 & 1.5\end{bmatrix}\) |
| \(\mu_1 = (2, 0)\)                                            |
| \(\Sigma_1 = \begin{bmatrix}2 & -0.5 \\ -0.5 & 1\end{bmatrix}\) |
|---------------------------------------------------------------|

Note that the covariance matrices now have non-zero off-diagonal entries: the features are correlated.

#+begin_src r
p <- 0.5
mu_0 <- c(0, 2)
sigma_0 <- matrix(c(2, -0.5, -0.5, 1), nrow = 2)
mu_1 <- c(2, 0)
sigma_1 <- matrix(c(1, 0.5, 0.5, 1.5), nrow = 2)

n <- 4000
set.seed(31415)
sample_mvn <- make_sample_mvn(n,
                              mu_0, sigma_0,
                              mu_1, sigma_1,
                              p)
density_mvn <- make_density_mvn(mu_0, sigma_0,
                                mu_1, sigma_1,
                                p,
                                -4, 5, -4, 5)


(ggplot() +
 gg_density(density_mvn, z = p_0_xy,
            alpha = 0.25) +
 gg_density(density_mvn, z = p_1_xy,
            alpha = 0.25) +
 gg_optimal(density_mvn)) +
(ggplot() +
 gg_sample(sample_mvn, alpha = 0.25) +
 gg_optimal(density_mvn)) +
plot_annotation("The Optimal Decision Boundary")
#+end_src

The optimal boundary is not too different.

#+begin_src r
fit_mvn_nb <- naivebayes::naive_bayes(factor(class) ~ x + y, data = sample_mvn)
pred_mvn_nb <- predict(fit_mvn_nb, newdata = density_mvn[, c("x", "y")], type = "prob")
density_mvn_nb <- cbind(density_mvn, "fitted" = pred_mvn_nb[, "1"])
gg_plot_boundary(sample_mvn, density_mvn_nb, title = "Naive Bayes")

anim <- animate_boundary(sample_mvn, density_mvn, 10, fit_and_predict_nb)

anim_save("/home/jovyan/work/bayeserror/nb_mvn_dependent.gif")

#+end_src

But the naive Bayes classifier isn't able to get a as exact of a fit this time.

Here is a confusion matrix. Now only accurate about 86% of the time.

#+begin_src r
density_mvn_nb[, "assigned"] <- ifelse(density_mvn_nb$fitted > 0, 1, 0)

caret::confusionMatrix(factor(density_mvn_nb$class),
                       factor(density_mvn_nb$assigned))
#+end_src

How badly does the model degrade as the features depart from independence? To investigate, let's see how the fitted boundary changes as we vary the dependence structure in each class.

We'll start with a diagonal covariance matrix for both classes (meaning no dependence), and then vary the off-diagonal entries for the first class.

#+begin_src r
p <- 0.5
mu_0 <- c(0, 2)
sigma_0 <- matrix(c(1, 0, 0, 1), nrow = 2)
mu_1 <- c(2, 0)

make_sigma <- function (x) {
    matrix(c(1, x, x, 1), nrow = 2)
}

make_mu <- function(x) {
    matrix(c(cos(x), sin(x)), nrow = 1)
}
>>>>>>> plotly

make_density <- function(...)
    make_density_mvn(mu_0, sigma_0,
                     make_mu(...), sigma_0,
                     p,
                     -3, 5, -3, 5)

make_sample <- function(...)
    make_sample_mvn(n,
                    mu_0, sigma_0,
                    make_mu(...), sigma_0,
                    p)

(ggplot() +
 gg_density(density_mvn, z = p_0_xy,
            alpha = 0.25) +
 gg_density(density_mvn, z = p_1_xy,
            alpha = 0.25) +
 gg_optimal(density_mvn)) +
(ggplot() +
 gg_sample(sample_mvn, alpha = 0.25) +
 gg_optimal(density_mvn)) +
plot_annotation("The Optimal Decision Boundary")

xs <- list(x = sin(seq(-2*pi+0.01, 2*pi-0.01, length = 100)))

xs <- list(x = seq(-2*pi+0.01, 2*pi-0.01, length = 100))

tmp <- make_density_animation_frame(make_sample,
                                    make_density,
                                    fit_and_predict_nb,
                                    xs)

anim <- animate_model_parameter(sample_mvn, tmp)
anim_save("/home/jovyan/work/mlanimation/animations/nb_3.gif")

#+end_src


** Linear Discriminant Analysis

#+begin_src r

fit_lda <- MASS::lda(class ~ x + y, data = density_mvn)
pred_lda <- predict(fit_lda, newdata = density_mvn)
density_lda <- cbind(density_mvn, "fitted" = pred_lda$posterior[, "1"] - 0.5)

#+end_src

** Quadratic Discriminant Analysis

#+begin_src r

fit_mvn_qda <- MASS::qda(class ~ x + y, data = sample_mvn)
pred_mvn_qda <- predict(fit_mvn_qda, newdata = density_mvn)
density_mvn_qda <- cbind(density_mvn, "fitted" = pred_mvn_qda$posterior[, "1"] - 0.5)
gg_plot_boundary(density_mvn_qda, sample_mvn, title = "QDA")

fit_mvn_qda <- MASS::qda(class ~ x + y, data = sample_mvn)
pred_mvn_qda <- predict(fit_mvn_qda, newdata = density_mvn)
density_mvn_qda <- cbind(density_mvn, "fitted" = pred_mvn_qda$posterior[, "1"] - 0.5)
gg_plot_boundary(density_mvn_qda, sample_mvn, title = "QDA")


fit_and_predict_qda <- function(sample, density) {
    fit_qda <- MASS::qda(class ~ x + y, data = sample)
    pred_qda <- predict(fit_qda, newdata = density)
    density_qda <- cbind(density, "fitted" = pred_qda$posterior[, "1"])
    density_qda
}

anim_mvn_qda <- animate_boundary(sample_mvn, density_mvn, 10, fit_and_predict_qda)

anim_save("/home/jovyan/work/bayeserror/qda_mvn.gif")

anim_mix_qda <- animate_boundary(sample_mix, density_mix, 10, fit_and_predict_qda)

anim_save("/home/jovyan/work/bayeserror/qda_mix.gif")


#+end_src

** Conclusion

All of these classifiers involved trade-offs.

* Classifiers
** Introduction

Looking at the decision boundary a classifier generates can give us some geometric intuition about the decision rule a classifier uses and how this decision rule changes as the classifier is trained on more data. 

** Mixture Discriminant Analysis

#+begin_src r
mda_opt <- function(data) {
    go <- function(n) {
        fit_mda <- mda::mda(class ~ x + y, data = data, subclasses = n)
        false <- (fit_mda$confusion[1, 2] + fit_mda$confusion[2, 1])
        true <- (fit_mda$confusion[1, 1] + fit_mda$confusion[2, 2])
        false / true
    }
    lapply(1:10, go)
}

fit_and_predict_mda <- function(sample, density) {
    fit_mda <- mda::mda(class ~ x + y, data = sample, subclasses = 10)
    pred_mda <- predict(fit_mda, newdata = density, type = "posterior")
    density_mda <- cbind(density, "fitted" = pred_mda[, "1"])
    density_mda
}

anim_mvn_mda <- animate_boundary(sample_mvn, density_mvn, 10,
                                 fit_and_predict_mda, start = 100)
anim_save("/home/jovyan/work/bayeserror/mda_mvn.gif")

anim_mix_mda <- animate_boundary(sample_mix, density_mix, 10,
                                 fit_and_predict_mda, start = 100)
anim_save("/home/jovyan/work/bayeserror/mda_mix.gif")

#+end_src

** Regression Models
*** Linear

#+begin_src r
fit_lm <- lm(class ~ x + y, data = sample_mvn)
pred_lm <- predict(fit_lm, newdata = density_mvn)
density_lm <- cbind(density_mvn, "fitted" = pred_lm - 0.5)

gg_plot_boundary(density_lm, sample_mvn, "Linear")

## class_lm <- ifelse(pred_lm > 0, 1, 0)

## confusion_lm <- table(density[, "class"],
##                    density[, "class_lm"],
##                    dnn = c("True", "Predicted"))

## fourfoldplot(confusion_lm, main = "Linear")

#+end_src

*** Logistic

#+begin_src r

fit_mvn_glm <- glm(class ~ x + y, data = sample_mvn, family = binomial)
pred_mvn_glm <- predict(fit_mvn_glm, newdata = density_mvn, type = "response")
density_mvn_glm <- cbind(density_mvn, "fitted" = pred_mvn_glm - 0.5)
gg_plot_boundary(density_mvn_glm, sample_mvn, "Logistic")

fit_mix_glm <- glm(class ~ x + y, data = sample_mix, family = binomial)
pred_mix_glm <- predict(fit_mix_glm, newdata = density_mix, type = "response")
density_mix_glm <- cbind(density_mix, "fitted" = pred_mix_glm - 0.5)
gg_plot_boundary(density_mix_glm, sample_mix, "Logistic")


fit_and_predict_glm <- function(sample, density) {
    fit_glm <- glm(class ~ x + y, data = sample, family = binomial)
    pred_glm <- predict(fit_glm, newdata = density_mvn, type = "response")
    density_glm <- cbind(density, fitted = pred_glm)
    return(density_glm)
}

anim_mvn_glm <- animate_boundary(sample_mvn, density_mvn, 10, fit_and_predict_glm)
anim_save("/home/jovyan/work/bayeserror/glm_mvn.gif", animation = anim_mvn_glm)

anim_mix_glm <- animate_boundary(sample_mix, density_mix, 10, fit_and_predict_glm)
anim_save("/home/jovyan/work/bayeserror/glm_mix.gif", animation = anim_mix_glm)

#+end_src

*** Logistic GAM

#+begin_src r

fit_mvn_gam <- mgcv::gam(class ~ s(x, y), class = "bernoulli", data = sample_mvn)
pred_mvn_gam <- predict(fit_mvn_gam, newdata = density_mvn, type = "response")
density_mvn_gam <- cbind(density_mvn, "fitted" = as.numeric(pred_mvn_gam) - 0.5)
gg_plot_boundary(density_mvn_gam, sample_mvn, title = "GAM")

fit_mix_gam <- mgcv::gam(class ~ s(x, y), class = "bernoulli", data = sample_mix)
pred_mix_gam <- predict(fit_mix_gam, newdata = density_mix, type = "response")
density_mix_gam <- cbind(density_mix, "fitted" = as.numeric(pred_mix_gam) - 0.5)
gg_plot_boundary(density_mix_gam, sample_mix, title = "GAM")


fit_and_predict_gam <- function(sample, density) {
    fit_gam <- mgcv::gam(class ~ s(x, y), class = "bernoulli", data = sample)
    pred_gam <- predict(fit_gam, newdata = density, type = "response")
    density_gam <- cbind(density, "fitted" = as.numeric(pred_gam))
    return(density_gam)
}

anim_mvn_gam <- animate_boundary(sample_mvn, density_mvn, 10, fit_and_predict_gam, 100)

anim_save("/home/jovyan/work/bayeserror/gam_mvn.gif")

anim_mix_gam <- animate_boundary(sample_mix, density_mix, 10, fit_and_predict_gam, 100)

anim_save("/home/jovyan/work/bayeserror/gam_mix.gif")

#+end_src

** Splines and Smoothers
*** MARS

#+begin_src r

fit_mvn_mars <- earth::earth(factor(class) ~ x + y,
                         data = sample_mvn,
                         glm = list(family = "binomial"))
pred_mvn_mars <- predict(fit_mvn_mars, newdata = density_mvn, type = "response")
density_mvn_mars <- cbind(density_mvn, "fitted" = as.numeric(pred_mvn_mars) - 0.5)
gg_plot_boundary(density_mvn_mars, sample_mvn, title = "MARS")


fit_mars <- earth::earth(factor(class) ~ x + y,
                         data = sample_mix,
                         glm = list(family = "binomial"))
pred_mars <- predict(fit_mars, newdata = density_mix, type = "response")
density_mars <- cbind(density_mix, "fitted" = as.numeric(pred_mars) - 0.5)
gg_plot_boundary(density_mars, sample_mix, title = "MARS")


fit_and_predict_mars <- function(sample, density) {
    fit_mars <- earth::earth(factor(class) ~ x + y,
                             data = sample,
                             glm = list(family = "binomial"))
    pred_mars <- predict(fit_mars, newdata = density, type = "response")
    density_mars <- cbind(density, "fitted" = as.numeric(pred_mars))
    density_mars
}

anim_mvn_mars <- animate_boundary(sample_mvn, density_mvn, 10, fit_and_predict_mars)
anim_save("/home/jovyan/work/bayeserror/mars_mvn.gif")
anim_mix_mars <- animate_boundary(sample_mix, density_mix, 10, fit_and_predict_mars)
anim_save("/home/jovyan/work/bayeserror/mars_mix.gif")

#+end_src

*** Poly-MARS

#+begin_src r

fit_pmars <- polspline::polymars(sample_mvn[["class"]],
                                 sample_mvn[, c("x", "y")],
                                 classify = TRUE)
pred_pmars <- predict(fit_pmars,
                      x = as.data.frame(density_mvn[, c("x", "y")]))
density_pmars <- cbind(density_mvn, "fitted" = pred_pmars[, 2] - 0.5)
gg_plot_boundary(density_pmars, sample_mvn, title = "PolyMARS")


fit_pmars <- polspline::polymars(sample_mix[["class"]],
                                 sample_mix[, c("x", "y")],
                                 classify = TRUE)
pred_pmars <- predict(fit_pmars,
                      x = as.data.frame(density_mix[, c("x", "y")]))
density_pmars <- cbind(density_mix, "fitted" = pred_pmars[, 2] - 0.5)
gg_plot_boundary(density_pmars, sample_mix, title = "PolyMARS")



fit_and_predict_polymars <- function(sample, density) {
    fit_pmars <- polspline::polymars(sample[["class"]],
                                     as.data.frame(sample[, c("x", "y")]),
                                     classify = TRUE)
    pred_pmars <- predict(fit_pmars,
                          x = as.data.frame(density[, c("x", "y")]))
    density_pmars <- cbind(density, "fitted" = pred_pmars[, 2])
    density_pmars
}

anim_mvn_pmars <- animate_boundary(sample_mvn, density_mvn, 10, fit_and_predict_polymars)

anim_save("/home/jovyan/work/bayeserror/pmars_mvn.gif")

anim_mix_pmars <- animate_boundary(sample_mix, density_mix, 10, fit_and_predict_polymars)

anim_save("/home/jovyan/work/bayeserror/pmars_mix.gif")

#+end_src

** Nearest Neighbors

#+begin_src r

pred_nn <- class::knn(train = sample_mvn[, c("x", "y")],
                             cl = factor(sample_mvn[, "class"]),
                             test = density_mvn[, c("x", "y")],
                             k = 5)
density_nn <- cbind(density_mvn, "fitted" = as.integer(pred_nn) - 2)
gg_plot_boundary(density_nn, sample_mvn, title = "Nearest Neighbors")


pred_nn <- class::knn(train = sample_mix[, c("x", "y")],
                      cl = factor(sample_mix[, "class"]),
                      test = density_mix[, c("x", "y")],
                      k = 5)
density_nn <- cbind(density_mix, "fitted" = as.integer(pred_nn) - 2)
gg_plot_boundary(density_nn, sample_mvn, title = "Nearest Neighbors")


#+end_src

#+begin_src r
fit_and_predict_knn <- function(sample, density) {
    pred_knn <- class::knn(train = sample[, c("x", "y")],
                           cl = factor(sample$class),
                           test = density[, c("x", "y")],
                           k = 5)
    density_knn <- cbind(density,
                         fitted = as.integer(pred_knn) - 1.5)
    return(density_knn)
}

anim_mvn_knn <- animate_boundary(sample_mvn, density_mvn, 10, fit_and_predict_knn)
anim_save("/home/jovyan/work/bayeserror/knn_mvn.gif", animation = anim_mvn_knn)

anim_mix_knn <- animate_boundary(sample_mix, density_mix, 10, fit_and_predict_knn)
anim_save("/home/jovyan/work/bayeserror/knn_mix.gif", animation = anim_mix_knn)

#+end_src

*** Kernel NN

#+begin_src r

fit_kknn <- kknn::train.kknn(factor(class) ~ x + y,
                             data = sample_mvn,
                             kernel = "gaussian")
pred_kknn <- predict(fit_kknn, newdata = density_mvn, type = "prob")
density_kknn <- cbind(density_mvn, "fitted" = pred_kknn[, 2] - 0.5)
gg_plot_boundary(density_kknn, sample_mvn, title = "KKNN")

#+end_src

** Support Vector Machines

#+begin_src r

fit_svm_points <- kernlab::ksvm(factor(class) ~ x + y,
                                data = sample_mvn,
                                kernel = "rbfdot",
                                prob.model = TRUE)
pred_svm_points <- kernlab::predict(fit_svm_points,
                                    newdata = density_mvn,
                                    type = "probabilities")
density_svm_points <- cbind(density_mvn, "fitted" = pred_svm_points[, "1"] - 0.5)
gg_plot_boundary(density_svm_points, sample_mvn, title = "SVM")



fit_svm <- kernlab::ksvm(factor(class) ~ x + y,
                         data = sample_mix,
                         kernel = "rbfdot",
                         prob.model = TRUE)
pred_svm <- kernlab::predict(fit_svm,
                             newdata = density_mix,
                             type = "probabilities")
density_svm <- cbind(density_mix, "fitted" = pred_svm[, "1"] - 0.5)
gg_plot_boundary(density_svm, sample_mix, title = "SVM")

fit_and_predict_svm <- function(sample, density) {
    fit_svm <- kernlab::ksvm(factor(class) ~ x + y,
                             data = sample,
                             kernel = "rbfdot",
                             prob.model = TRUE)
    pred_svm <- kernlab::predict(fit_svm,
                             newdata = density,
                             type = "probabilities")
    density_svm <- cbind(density, "fitted" = pred_svm[, "1"])
    density_svm
}

anim_mvn_svm <- animate_boundary(sample_mvn, density_mvn, 10, fit_and_predict_svm)
anim_save("/home/jovyan/work/bayeserror/svm_mvn.gif")
anim_mix_svm <- animate_boundary(sample_mix, density_mix, 10, fit_and_predict_svm)
anim_save("/home/jovyan/work/bayeserror/svm_mix.gif")

#+end_src

** Trees
*** Decision Trees

#+begin_src r

fit_rpart_points <- rpart::rpart(class ~ x + y, data = sample_mvn, method = "class")
pred_rpart_points <- predict(fit_rpart_points, newdata = density_mvn)
density_rpart_points <- cbind(density_mvn, "fitted" = pred_rpart_points[, "1"] - 0.5)
gg_plot_boundary(density_rpart_points, sample_mvn, title = "Decision Tree")

fit_rpart <- rpart::rpart(class ~ x + y, data = sample_mix, method = "class")
pred_rpart <- predict(fit_rpart, newdata = density_mix)
density_rpart <- cbind(density_mix, "fitted" = pred_rpart[, "1"] - 0.5)
gg_plot_boundary(density_rpart, sample_mix, title = "Decision Tree")

fit_and_predict_rpart <- function(sample, density, ...) {
    fit_rpart <- rpart::rpart(class ~ x + y, data = sample,
                              method = "class", ...)
    pred_rpart <- predict(fit_rpart, newdata = density)
    density_rpart <- cbind(density, "fitted" = pred_rpart[, "1"])
    density_rpart
}

anim_mvn_rpart <- animate_boundary(sample_mvn, density_mvn, 10, fit_and_predict_rpart)
anim_save("/home/jovyan/work/bayeserror/rpart_mvn.gif")
anim_mix_rpart <- animate_boundary(sample_mix, density_mix, 10, fit_and_predict_rpart)
anim_save("/home/jovyan/work/bayeserror/rpart_mix.gif")

#+end_src

*** Random Forests

#+begin_src r

fit_rf <- ranger::ranger(factor(class) ~ x + y,
                         data = sample_mvn,
                         probability = TRUE)
pred_rf <- predict(fit_rf, data = density_mvn)
density_rf <- cbind(density_mvn, "fitted" = pred_rf$predictions[, "1"] - 0.5)
gg_plot_boundary(density_rf, sample_mvn, title = "Random Forest")


fit_rf <- ranger::ranger(factor(class) ~ x + y,
                         data = sample_mix,
                         probability = TRUE)
pred_rf <- predict(fit_rf, data = density_mix)
density_rf <- cbind(density_mix, "fitted" = pred_rf$predictions[, "1"] - 0.5)
gg_plot_boundary(density_rf, sample_mix, title = "Random Forest")



fit_and_predict_rf <- function(sample, density) {
    fit_rf <- ranger::ranger(factor(class) ~ x + y,
                             data = sample,
                             probability = TRUE)
    pred_rf <- predict(fit_rf, data = density)
    density_rf <- cbind(density, "fitted" = pred_rf$predictions[, "1"])
    return(density_rf)
}

anim_mvn_rf <- animate_boundary(sample_mvn, density_mvn, 10, fit_and_predict_rf)

anim_save("/home/jovyan/work/bayeserror/rf_mvn.gif", animation = anim_mvn_rf)

anim_mix_rf <- animate_boundary(sample_mix, density_mix, 10, fit_and_predict_rf)
anim_save("/home/jovyan/work/bayeserror/rf_mix.gif", animation = anim_mix_rf)

#+end_src

*** BART

*** ExtraTrees

#+begin_src r
## Don't run out of Java heap
options(java.parameters = "-Xmx8g")

fit_etrees <- extraTrees::extraTrees(x = sample_mvn[, c("x", "y")],
                                     y = factor(sample_mvn$class))
pred_etrees <- predict(fit_etrees,
                       newdata = density_mvn[, c("x", "y")],
                       probability = TRUE)
density_mvn_etrees <- cbind(density_mvn, "fitted" = pred_mda[, "1"] - 0.5)
gg_plot_boundary(density_mvn_etrees, sample_mvn, title = "")


fit_and_predict_etrees <- function(sample, density) {
    fit_etrees <- extraTrees::extraTrees(x = sample[, c("x", "y")],
                                     y = factor(sample$class))
    pred_etrees <- predict(fit_etrees,
                       newdata = density[, c("x", "y")],
                       probability = TRUE)
    density_etrees <- cbind(density, "fitted" = pred_mda[, "1"])
    density_etrees
}

anim_mvn_etrees <- animate_boundary(sample_mvn, density_mvn, 10,
                                    fit_and_predict_etrees)

anim_save("/home/jovyan/work/bayeserror/etrees_mvn.gif")

anim_mix_mda <- animate_boundary(sample_mix, density_mix, 10,
                                 fit_and_predict_etrees)
anim_save("/home/jovyan/work/bayeserror/etrees_mix.gif")



#+end_src

** Gradient Boosting
*** gbm

#+begin_src r

fit_gbm <- gbm::gbm(class ~ x + y,
                    data = sample_mvn,
                    n.trees = 100,
                    distribution = "bernoulli")
pred_gbm <- predict(fit_gbm,
                    n.trees = 100,
                    newdata = density_mvn,
                    type = "response")
density_gbm <- cbind(density_mvn, "fitted" = pred_gbm - 0.5)
gg_plot_boundary(density_gbm, sample_mvn, title = "Boosted Trees")


fit_gbm <- gbm::gbm(class ~ x + y,
                    data = sample_mix,
                    n.trees = 500,
                    distribution = "bernoulli")
pred_gbm <- predict(fit_gbm,
                    n.trees = 500,
                    newdata = density_mix,
                    type = "response")
density_gbm <- cbind(density_mix, "fitted" = pred_gbm-0.5)
gg_plot_boundary(density_gbm, sample_mix, title = "Boosted Trees")

#+end_src

*** xgboost

#+begin_src r

set.seed(31415)
sample_xg <- xgboost::xgb.DMatrix(
                          as.matrix(sample_mvn[, c("x", "y")]),
                          label = as.numeric(sample_mvn$class))
xgcv <- xgboost::xgb.cv(data = sample_xg,
                        nrounds = 50,
                        early_stopping_rounds = 3,
                        nfold = 5,
                        objective = "binary:logistic")
fit_xg <- xgboost::xgboost(data = sample_xg,
                           nrounds = xgcv$best_iteration,
                           objective = "binary:logistic")
pred_xg <- predict(fit_xg, newdata = as.matrix(density_mvn[, c("x", "y")]))
density_xg <- cbind(density_mvn, "fitted" = pred_xg - 0.5)
gg_plot_boundary(density_xg, sample_mvn, title = "xgboost")


set.seed(31415)
sample_xg <- xgboost::xgb.DMatrix(
                          as.matrix(sample_mix[, c("x", "y")]),
                          label = as.numeric(sample_mix$class))
xgcv <- xgboost::xgb.cv(data = sample_xg,
                        nrounds = 50,
                        early_stopping_rounds = 3,
                        nfold = 5,
                        objective = "binary:logistic")
fit_xg <- xgboost::xgboost(data = sample_xg,
                           nrounds = xgcv$best_iteration,
                           objective = "binary:logistic")
pred_xg <- predict(fit_xg, newdata = as.matrix(density_mix[, c("x", "y")]))
density_xg <- cbind(density_mix, "fitted" = pred_xg - 0.5)
gg_plot_boundary(density_xg, sample_mix, title = "xgboost")


fit_and_predict_xgboost <- function(sample, density, ...) {
    set.seed(31415)
    sample_xg <- xgboost::xgb.DMatrix(
                              as.matrix(sample[, c("x", "y")]),
                              label = as.numeric(sample$class))
    xgcv <- xgboost::xgb.cv(data = sample_xg,
                            nrounds = 50,
                            early_stopping_rounds = 3,
                            nfold = 5,
                            objective = "binary:logistic",
                            verbose = 0,
                            ...)
    fit_xg <- xgboost::xgboost(data = sample_xg,
                               nrounds = xgcv$best_iteration,
                               objective = "binary:logistic",
                               verbose = 0,
                               ...)
    pred_xg <- predict(fit_xg, newdata = as.matrix(density[, c("x", "y")]))
    density_xg <- cbind(density, "fitted" = pred_xg)
    return(density_xg)
}

anim_mvn_xgb <- animate_boundary(sample_mvn, density_mvn, 10, fit_and_predict_xgboost)

anim_save("/home/jovyan/work/bayeserror/xgboost_mvn.gif")
anim_mix_xgb <- animate_boundary(sample_mix, density_mix, 10, fit_and_predict_xgboost)
anim_save("/home/jovyan/work/bayeserror/xgboost_mix.gif")

#+end_src

*** mboost

#+begin_src r
fit_mix_mb <- mboost::mboost(factor(class) ~ bspatial(x, y),
                             data = sample_mix,
                             family = Binomial(),
                             control = boost_control(mstop = 1000,
                                                     nu = 0.1))
pred_mix_mb <- predict(fit_mix_mb, newdata = density_mix, type = "response")
density_mix_mb <- cbind(density_mix, "fitted" = as.numeric(pred_mix_mb) - 0.5)
gg_plot_boundary(density_mix_mb, sample_mix)


fit_and_predict_mb <- function(sample, density) {
    fit_mb <- mboost::mboost(factor(class) ~ bspatial(x, y),
                                 data = sample,
                                 family = Binomial(),
                                 control = boost_control(mstop = 1000,
                                                         nu = 0.1))
    pred_mb <- predict(fit_mb, newdata = density, type = "response")
    density_mb <- cbind(density, "fitted" = as.numeric(pred_mb))
    density_mb
}

anim <- animate_boundary(sample_mvn, density_mvn, 10, fit_and_predict_mb)
anim_save("/home/jovyan/work/bayeserror/mb_mvn.gif")

anim <- animate_boundary(sample_mix, density_mix, 10, fit_and_predict_mb)
anim_save("/home/jovyan/work/bayeserror/mb_mix.gif")

#+end_src

** Neural Networks
*** Feedforward Perceptrons

#+begin_src r

set.seed(31415)
fit_nn <- nnet::nnet(factor(class) ~ x + y,
                     data = sample_mvn,
                     size = 4,
                     decay = 0.01,
                     rang = 0.3,
                     maxit = 200)
pred_nn <- predict(fit_nn, newdata = density_mvn, type = "raw")
density_nn <- cbind(density_mvn, "fitted" = pred_nn - 0.5)
gg_plot_boundary(density_nn, sample_mvn, title = "Neural Network")

set.seed(31415)
fit_nn <- nnet::nnet(factor(class) ~ x + y,
                     data = sample_mix,
                     size = 4,
                     decay = 0.01,
                     rang = 0.3,
                     maxit = 200)
pred_nn <- predict(fit_nn, newdata = density_mix, type = "raw")
density_nn <- cbind(density_mix, "fitted" = pred_nn - 0.5)
gg_plot_boundary(density_nn, sample_mix, title = "Neural Network")

fit_and_predict_nn <- function(sample, density, seed = 31415) {
    set.seed(seed)
    fit_nn <- nnet::nnet(factor(class) ~ x + y,
                         data = sample,
                         size = 4,
                         decay = 0.01,
                         rang = 0.3,
                         maxit = 200,
                         trace = FALSE)
    pred_nn <- predict(fit_nn, newdata = density, type = "raw")
    density_nn <- cbind(density, "fitted" = pred_nn)
    density_nn
}

anim_mvn_nn <- animate_boundary(sample_mvn, density_mvn, 10, fit_and_predict_nn)
anim_save("/home/jovyan/work/bayeserror/nn_mvn.gif")
anim_mix_n <- animate_boundary(sample_mix, density_mix, 10, fit_and_predict_nn)
anim_save("/home/jovyan/work/bayeserror/nn_mix.gif")

#+end_src

*** Extreme Learning Machines

#+begin_src r
set.seed(31415)
fit_elm <- elmNNRcpp::elm_train(x = as.matrix(sample_mvn[, c("x", "y")]),
                                y = elmNNRcpp::onehot_encode(sample_mvn[["class"]]),
                                nhid = 10,
                                actfun = "sig")
pred_elm <- elmNNRcpp::elm_predict(fit_elm,
                                   as.matrix(density_mvn[, c("x", "y")]))
density_elm <- cbind(density_mvn, "fitted" = pred_elm[, 1] - 0.5)
gg_plot_boundary(density_elm, sample_mvn, title = "ELM")


fit_and_predict_elm <- function(sample, density) {
    set.seed(31415)
    fit_elm <- elmNNRcpp::elm_train(x = as.matrix(sample[, c("x", "y")]),
                                    y = elmNNRcpp::onehot_encode(sample[["class"]]),
                                    nhid = 10,
                                    actfun = "sig")
    pred_elm <- elmNNRcpp::elm_predict(fit_elm,
                                       as.matrix(density[, c("x", "y")]))
    density_elm <- cbind(density, "fitted" = pred_elm[, 1])
    return(density_elm)
}

anim_mvn_elm <- animate_boundary(sample_mvn, density_mvn, 10, fit_and_predict_elm)
anim_save("/home/jovyan/work/bayeserror/elm_mvn.gif")

anim_mix_elm <- animate_boundary(sample_mix, density_mix, 10, fit_and_predict_elm)
anim_save("/home/jovyan/work/bayeserror/elm_mix.gif")





#+end_src

** Gaussian Process

#+begin_src r

fit_mvn_gp <- kernlab::gausspr(factor(class) ~ x + y,
                           data = sample_mvn,
                           kernel = "rbfdot")
pred_mvn_gp <- predict(fit_mvn_gp,
                   newdata = density_mvn,
                   type = "probabilities")
density_mvn_gp <- cbind(density_mvn, "fitted" = pred_mvn_gp[, "1"] - 0.5)
gg_plot_boundary(density_mvn_gp, sample_mvn, title = "Gaussian Process")

fit_mix_gp <- kernlab::gausspr(factor(class) ~ x + y,
                           data = sample_mix,
                           kernel = "rbfdot")
pred_mix_gp <- predict(fit_mix_gp,
                   newdata = density_mix,
                   type = "probabilities")

density_mix_gp <- cbind(density_mix, "fitted" = pred_mix_gp[, "1"])

gg_plot_boundary(sample_mix, density_mix_gp, title = "Gaussian Process")

fit_and_predict_gp <- function(sample, density) {
    fit_gp <- kernlab::gausspr(factor(class) ~ x + y,
                                   data = sample,
                                   kernel = "rbfdot")
    pred_gp <- predict(fit_gp,
                           newdata = density,
                           type = "probabilities")
    density_gp <- cbind(density, "fitted" = pred_gp[, "1"])
    density_gp
}

anim_mvn_gp <- animate_boundary(sample_mvn, density_mvn, 10, fit_and_predict_mvn)

anim_save("/home/jovyan/work/bayeserror/gp_mvn.gif")

anim_mix_gp <- animate_boundary(sample_mix, density_mix, 10, fit_and_predict_gp)
anim_save("/home/jovyan/work/bayeserror/gp_mix.gif")


#+end_src

** Plotting Functions

*** Static

#+begin_src r
gg_plot_boundary <- function(sample, density, title = "") {
    ggplot() +
    ## gg_sample(data = density, size = 1.5, alpha = 0.1, shape = 15) +
    gg_sample(data = sample) +
    gg_density(data = density, z = optimal, breaks = c(0), linetype = 2) +
    gg_density(data = density, z = fitted, breaks = c(0.5)) +
    coord_fixed(expand = FALSE) +
    xlim(min(density$x), max(density$y)) +
    ylim(min(density$y), max(density$y))
}

#+end_src

*** Animation

#+begin_src r

##' Animate the evolution of a decision boundary as the sample size grows
##'
##' @param sample `data.frame`: the complete sample data; should have
##'     columns `x`, `y`, and `class`
##' @param density `data.frame`: the density distribution of `x` and
##'     `y`; should have columns `x`, `y`, and `optimal`, the contours
##'     of the optimal decision distribution
##' @param delta `integer`: how many points to add at each step of the
##'     animation
##' @param fit_and_predict `function(sample, density)`: fits a learner
##'     to the sample data and returns its predictions on the density
animate_boundary <- function(sample, density, delta, fit_and_predict, start = 0) {
    ## a data.frame with successive groups of `data` of size `delta`;
    ## `data` is randomized before sequencing
    sequence_data <- function(data, delta) {
        rows <- nrow(data)
        n <- (rows - start) / delta
        data <- data[sample(nrow(data)), ]
        go <- function(i) {
            h <- min(i * delta + start, rows)
            bind_cols(
                head(data, h),
                group = rep.int(i, h))
        }
        sequenced <- bind_rows(lapply(1:n, go))
        return(sequenced)
    }
    ## Sequence the sample data
    sample_sequenced <- sequence_data(sample, delta)
    ## Sequence the density data and attach predictions from the sample
    density_sequenced <- sample_sequenced %>%
        group_by(group) %>%
        group_modify(~ fit_and_predict(.x, density)) %>%
        ungroup()
    ## Define the animation
    anim <- ggplot() +
        gg_plot_boundary(sample_sequenced, density_sequenced) +
        ## Animate the sample and the fitted boundary
        transition_manual(group)
    anim <- animate(anim, renderer = gifski_renderer(),
                    width = 800, height = 800)
    anim
}

##' Animate changes in a decision boundary as a parameter in a model
##' changes
##'
##' @param sample `data.frame`: the complete sample data; should have
##'     columns `x`, `y`, and `class`
##' @param density `data.frame`: the density distribution of `x` and
##'     `y`; should have columns `x`, `y`, and `optimal`, the contours
##'     of the optimal decision distribution
##' @param fit_and_predict `function(sample, density, param)`: fits a
##'     learner to the sample data and returns its predictions on the
##'     density as a data frame; `param` is the parameter value to
##'     vary over
##' @param param_name `string`: the name of the parameter to vary over
##' @param param_seq `vector`: a vector of values for the parameter on
##'     which to animate the model
animate_model_parameter <- function(sample, density,
                                    fit_and_predict,
                                    param_seq) {
    n <- length(param_seq)
    go <- function(i) {
        fitted <- fit_and_predict(sample, density, param_seq[[i]])
        mutate(fitted, "group" = i)
    }
    density_sequenced <- bind_rows(lapply(1:n, go))
     ## Define the animation
    anim <- ggplot() +
        gg_plot_boundary(sample, density_sequenced) +
        ## Animate the sample and the fitted boundary
        transition_manual(group)
    anim <- animate(anim, renderer = gifski_renderer(),
                    width = 800, height = 800)
    anim
}

cp_list <- lapply(seq(from = -4, to = -1, length=50), function(x) 10^x)
tmp <- animate_model_parameter(sample_mvn, density_mvn,
                               function(x, y, z)
                                   fit_and_predict_rpart(x, y,
                                                         control = list("cp" = z)),
                               cp_list)
anim_save("/home/jovyan/work/bayeserror/tmp.gif")

eta <- lapply(seq(from = -4, to = -0.5, length = 50), function(x) 10^x)

subsample <- seq(1, 1, length = 50)

tmp <- animate_model_parameter(sample_mvn, density_mvn,
                               function(x, y, z)
                                   fit_and_predict_xgboost(x, y,
                                                           "subsample" = z),
                               max_depth)

anim_save("/home/jovyan/work/bayeserror/tmp.gif")



#+end_src

*** Lattice plots

#+begin_src r

lattice_plot_boundary <- function(density, sample, title) {
    fitted_class <- ifelse(density[, "fitted"] > 0, 1, 0)
    ## classes in the feature grid
    lattice::xyplot(y ~ x, groups = fitted_class,
                    data = density,
                    cex = 1, pch = 20, alpha = 0.1,
                    aspect = 1) +
    ## the optimal decision boundary
    lattice::contourplot(optimal ~ x + y,
                         data = density,
                         at = c(0),
                         labels = FALSE,
                         lwd = 3,
                         lty = 2,
                         aspect = 1,
                         main = title) +
    ## the fitted decision boundary
    lattice::contourplot(fitted ~ x + y,
                         data = density,
                         at = c(0),
                         labels = FALSE,
                         lwd = 3) +
    ## the sample
    lattice::xyplot(y ~ x, groups = class,
                    data = sample,
                    pch = 19, alpha = 0.5)
}


lattice::levelplot(p_0 ~ x + y,
                   contour = TRUE,
                   region = FALSE,
                   cuts = 10,
                   data = density_mvn,
                   aspect = 1) +
    lattice::levelplot(p_1 ~ x + y,
                       contour = TRUE,
                       region = FALSE,
                       cuts = 10,
                       data = density_mvn)

lattice::levelplot(optimal ~ x + y,
                   data = density_mvn,
                   aspect = 1,
                   cuts = 20,
                   contour = TRUE) +
    lattice::contourplot(optimal ~ x + y,
                         data = density_mvn,
                         at = c(0),
                         labels = FALSE,
                         lwd = 3)

lattice::levelplot(p_0 ~ x + y,
                   contour = TRUE,
                   region = FALSE,
                   cuts = 5,
                   data = density_mvn,
                   aspect = 1) +
    lattice::levelplot(p_1 ~ x + y,
                       contour = TRUE,
                       region = FALSE,
                       cuts = 5,
                       data = density_mvn) +
    lattice::contourplot(optimal ~ x + y,
                         data = density_mvn,
                         at = c(0),
                         labels = FALSE,
                         lwd = 3)
    
lattice::contourplot(optimal ~ x + y,
                     data = density_mvn,
                     at = c(0),
                     labels = FALSE,
                     lwd = 3,
                     aspect = 1) +
    lattice::xyplot(y ~ x, groups = class, data = points)

#+end_src

* Loss Functions

In some data sets, two observations might have the same features but belong to different classes. (Similar people can have different opinions.) This means that /any/ consistent classification rule we use on that data set will /always/ misclassify something. This is for the simple reason that if two things look exactly the same, there is no way to tell them apart. (A classification rule is a function: given the same input, it must always produce the same output.)

# TODO image

So, often the best that we can do is to assign classes /probabilistically/: the more often a set of features occurs in some class, the higher the probability it belongs to that class.

# TODO image

In terms of probability distributions, we are saying that a classification rule must have non-zero expected error whenever the conditional distributions of its features overlap, that is, when you have a situation like \( P(X \mid C = 0) \gt 0 \) and \( P(X \mid C = 1) \gt 0 \) for features $X$ and classes $C$.

The /optimal/ decision boundary for a problem is the boundary for the rule that minimizes the number of expected misclassifications. This is the boundary for the rule that assigns each observation to its most probable class; that is, whichever class its feature set occurs in most often. (More generally, we could minimize a /loss function/.)

This optimal decision rule we can define like this:
\[ \hat{C} = \operatorname*{argmax}_c P(C = c \mid x) \]
# TODO check this formula
where, again, $C$ is the class and $X$ is the feature set.


*** Aside

Sometimes, this is also called the "Bayes" optimal boundary since it is the rule that minimizes the Bayes loss of the problem. This remaining loss is called the *Bayes error*. It is a measure of how difficult a classification problem is. This is because /no/ classification rule can ever predict classes on a data set with less error than the Bayes error.

